name: "Quality Gate"

on:
  pull_request:
    branches: [ "main", "develop" ]

# Cancel superseded runs for PRs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality-gate:
    name: "quality-gate"
    runs-on: ubuntu-latest
    timeout-minutes: 15

    # Least-privilege permissions
    permissions:
      contents: read         # Required to checkout code
      pull-requests: write   # Required to comment on PRs

    # Expose coverage as job output
    outputs:
      coverage-percentage: ${{ steps.coverage-check.outputs.coverage-percentage }}
      coverage-passed: ${{ steps.coverage-check.outputs.coverage-passed }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v5

    - name: Set up Python
      uses: actions/setup-python@v6
      with:
        python-version: '3.10'  # Match your project's Python requirement
        cache: 'pip'

    # Cache PDM dependencies for faster builds
    - name: Cache PDM dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/pdm
          .venv
        key: ${{ runner.os }}-pdm-${{ hashFiles('**/pyproject.toml', '**/pdm.lock') }}
        restore-keys: |
          ${{ runner.os }}-pdm-

    - name: Install PDM
      run: |
        python -m pip install --upgrade pip
        pip install pdm

    - name: Install dependencies
      run: |
        pdm install --dev

    # Run tests with coverage - customize command as needed for your project
    - name: Run tests with coverage
      run: |
        # Generate both XML (for parsing) and HTML (for artifacts) coverage reports
        pdm run pytest --cov=src --cov-report=xml --cov-report=html --cov-report=term-missing --cov-fail-under=90
      continue-on-error: true  # Don't fail here, let coverage check handle it

    # Parse coverage percentage and check threshold
    - name: Check coverage threshold
      id: coverage-check
      run: |
        # Parse coverage percentage from coverage.xml
        if [ -f "coverage.xml" ]; then
          # Extract coverage percentage using python
          COVERAGE=$(python -c "
        import xml.etree.ElementTree as ET
        try:
            tree = ET.parse('coverage.xml')
            root = tree.getroot()
            coverage_attr = root.attrib.get('line-rate', '0')
            coverage_percent = int(float(coverage_attr) * 100)
            print(coverage_percent)
        except Exception as e:
            print('0')
        ")
          echo "Coverage: ${COVERAGE}%"
          echo "coverage-percentage=${COVERAGE}" >> $GITHUB_OUTPUT

          # Check if coverage meets threshold
          THRESHOLD=90
          if [ "$COVERAGE" -ge "$THRESHOLD" ]; then
            echo "✅ Coverage ${COVERAGE}% meets threshold ${THRESHOLD}%"
            echo "coverage-passed=true" >> $GITHUB_OUTPUT
            echo "COVERAGE_STATUS=✅ PASSED" >> $GITHUB_ENV
            echo "COVERAGE_COLOR=28a745" >> $GITHUB_ENV
          else
            echo "❌ Coverage ${COVERAGE}% below threshold ${THRESHOLD}%"
            echo "coverage-passed=false" >> $GITHUB_OUTPUT
            echo "COVERAGE_STATUS=❌ FAILED" >> $GITHUB_ENV
            echo "COVERAGE_COLOR=d73a49" >> $GITHUB_ENV
            exit 1
          fi

          echo "COVERAGE_PERCENT=${COVERAGE}" >> $GITHUB_ENV
          echo "COVERAGE_THRESHOLD=${THRESHOLD}" >> $GITHUB_ENV
        else
          echo "❌ No coverage.xml file found"
          echo "coverage-percentage=0" >> $GITHUB_OUTPUT
          echo "coverage-passed=false" >> $GITHUB_OUTPUT
          echo "COVERAGE_STATUS=❌ NO COVERAGE DATA" >> $GITHUB_ENV
          echo "COVERAGE_COLOR=d73a49" >> $GITHUB_ENV
          echo "COVERAGE_PERCENT=0" >> $GITHUB_ENV
          echo "COVERAGE_THRESHOLD=90" >> $GITHUB_ENV
          exit 1
        fi

    # Upload coverage reports as artifacts
    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      if: always()  # Upload even if tests failed
      with:
        name: coverage-reports
        path: |
          coverage.xml
          htmlcov/
        retention-days: 30

    # Comment on PR with coverage results (only for non-fork PRs)
    - name: Comment PR with coverage results
      if: github.event.pull_request.head.repo.fork == false && always()
      uses: actions/github-script@v8
      with:
        script: |
          const coveragePercent = process.env.COVERAGE_PERCENT || '0';
          const coverageThreshold = process.env.COVERAGE_THRESHOLD || '90';
          const coverageStatus = process.env.COVERAGE_STATUS || '❌ UNKNOWN';
          const coverageColor = process.env.COVERAGE_COLOR || 'd73a49';

          const body = `## 🧪 Code Coverage Report

          ![Coverage](https://img.shields.io/badge/Coverage-${coveragePercent}%25-${coverageColor})

          **Status:** ${coverageStatus}
          **Coverage:** ${coveragePercent}%
          **Threshold:** ${coverageThreshold}%

          ${coveragePercent >= coverageThreshold ?
            '✅ **Great job!** Your code coverage meets the quality threshold.' :
            `❌ **Coverage below threshold.** Please add tests to reach ${coverageThreshold}% coverage.`
          }

          ---
          *This comment was automatically generated by the Quality Gate workflow.*`;

          // Find existing comment
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });

          const existingComment = comments.data.find(comment =>
            comment.body.includes('🧪 Code Coverage Report')
          );

          if (existingComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existingComment.id,
              body: body
            });
          } else {
            // Create new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
          }